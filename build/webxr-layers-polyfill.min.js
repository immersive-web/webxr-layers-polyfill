/**
 * @license
 * webxr-layers-polyfill
 * Version 1.0.0
 * Copyright (c) 2021 Facebook, Inc. and its affiliates.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
*/
/**
 * @license
 * gl-matrix 
 * Version 3.3.0
 * Copyright (c) 2015-2020, Brandon Jones, Colin MacKenzie IV.
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
*/
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).WebXRLayersPolyfill=t()}(this,(function(){"use strict";var e,t;!function(e){e.texture="texture",e["texture-array"]="texture-array"}(e||(e={})),function(e){e.default="default",e.mono="mono",e.stereo="stereo",e["stereo-left-right"]="stereo-left-right",e["stereo-top-bottom"]="stereo-top-bottom"}(t||(t={}));const r=e=>e&&"function"==typeof e.getOffsetReferenceSpace,i=()=>"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{};class s{constructor(){this._hasRunDeferredInitialize=!1,this._media=null}initialize(e,t){this.session=e,t&&(this.context=t),this.blendTextureSourceAlpha=!0,this.chromaticAberrationCorrection=!1}destroy(){this._colorTextures=[],this._depthStencilTextures=[]}addEventListener(e,t,r){}dispatchEvent(e){return!1}removeEventListener(e,t,r){}getContext(){return this.context}getTextureType(){throw new Error("Unimplemented")}get colorTextures(){return this._colorTextures}get depthStencilTextures(){return this._depthStencilTextures}get colorTexturesMeta(){return this._texturesMeta}get media(){return this.isMediaLayer()||console.warn("Attempted to retrieve media from a non-media layer"),this._media}determineLayoutAttribute(r,i,s){if(!(i instanceof WebGL2RenderingContext)&&r===e["texture-array"])throw new TypeError;if(s===t.mono)return s;if(s===t.default){if(this.session.internalViews&&1===this.session.internalViews.length)return t.mono;if(r===e["texture-array"])return s}return s===t.default||s===t.stereo?t["stereo-left-right"]:s}isMediaLayer(){return null!==this._media}_deferredInitialize(){}initializeIfNeeded(){this._hasRunDeferredInitialize||(this._hasRunDeferredInitialize=!0,this._deferredInitialize())}_allocateColorTexturesInternal(r,i){let s=this.session.internalViews;if(s&&0!==s.length){if(this.initializeIfNeeded(),this.layout===t.mono){if(r===e["texture-array"]){const e=this._createNewColorTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.colorFormat);return this._texturesMeta=[e],void(this._colorTextures=[e.texture])}{const e=this._createNewColorTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.colorFormat);return this._texturesMeta=[e],void(this._colorTextures=[e.texture])}}if(this.layout===t.stereo){if(r===e["texture-array"]){const e=this._createNewColorTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.colorFormat,2);return this._texturesMeta=[e],void(this._colorTextures=[e.texture])}{const e=this._createNewColorTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.colorFormat),t=this._createNewColorTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.colorFormat);return this._texturesMeta=[e,t],void(this._colorTextures=[e.texture,t.texture])}}if(this.layout===t["stereo-left-right"]){const e=this._createNewColorTexture(2*i.viewPixelWidth,i.viewPixelHeight,r,i.colorFormat);return this._texturesMeta=[e],void(this._colorTextures=[e.texture])}if(this.layout===t["stereo-top-bottom"]){const e=this._createNewColorTexture(i.viewPixelWidth,2*i.viewPixelHeight,r,i.colorFormat);return this._texturesMeta=[e],void(this._colorTextures=[e.texture])}}else console.warn("We can't allocate color textures without views")}_allocateDepthStencilTexturesInternal(r,i){if(i.depthFormat){if(this._getSupportedDepthFormats().indexOf(i.depthFormat)<0)throw new Error("Depth format provided is not supported in non-projection layers.");if(i.mipLevels<1)throw new Error("Invalid miplevel. Miplevel needs to be >= 1");if(this.layout===t.mono){if(r===e["texture-array"]){const e=this._createNewDepthStencilTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.depthFormat);return void(this._depthStencilTextures=[e.texture])}{const e=this._createNewColorTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.depthFormat);return void(this._depthStencilTextures=[e.texture])}}if(this.layout===t.stereo){if(r===e["texture-array"]){const e=this._createNewDepthStencilTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.depthFormat,2);return void(this._depthStencilTextures=[e.texture])}{const e=this._createNewDepthStencilTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.depthFormat),t=this._createNewDepthStencilTexture(i.viewPixelWidth,i.viewPixelHeight,r,i.depthFormat);return void(this._depthStencilTextures=[e.texture,t.texture])}}if(this.layout!==t["stereo-left-right"])if(this.layout!==t["stereo-top-bottom"]);else{const e=this._createNewDepthStencilTexture(i.viewPixelWidth,2*i.viewPixelHeight,r,i.depthFormat);this._depthStencilTextures=[e.texture]}else{const e=this._createNewDepthStencilTexture(2*i.viewPixelWidth,i.viewPixelHeight,r,i.depthFormat);this._depthStencilTextures=[e.texture]}}else this._depthStencilTextures=[]}_createNewColorTexture(e,t,r,i,s=1){return this._createGenericPolyfillTexture(r,e,t,i,0,s)}_createNewDepthStencilTexture(e,t,r,i,s=1){return this._createGenericPolyfillTexture(r,e,t,i,0,s)}_createGenericPolyfillTexture(t,r,i,s,o=0,a=1){if(t===e["texture-array"]&&a<=1&&console.warn("creating a texture array with a single layer..."),t===e["texture-array"]&&this.context instanceof WebGLRenderingContext)throw new Error("WebGL 1 does not support texture array");let n=this.context.createTexture(),h={width:r,height:i,layers:a,type:t,textureFormat:s,texture:n},l=s;this.context instanceof WebGL2RenderingContext&&l===this.context.DEPTH_COMPONENT&&(l=this.context.DEPTH_COMPONENT16);let u=this.context.UNSIGNED_BYTE;return s!==this.context.DEPTH_COMPONENT&&s!==this.context.DEPTH_COMPONENT16||(u=this.context.UNSIGNED_INT),t===e["texture-array"]&&this.context instanceof WebGL2RenderingContext?(console.warn("texture-array layers are supported...questionably in the polyfill at the moment. Use at your own risk."),this.context.bindTexture(this.context.TEXTURE_2D_ARRAY,n),s===this.context.DEPTH_COMPONENT||s===this.context.DEPTH_COMPONENT16||s===this.context.DEPTH_COMPONENT24?this.context.texStorage3D(this.context.TEXTURE_2D_ARRAY,1,l,r,i,a):this.context.texImage3D(this.context.TEXTURE_2D_ARRAY,0,l,r,i,a,0,s,u,null)):(this.context.bindTexture(this.context.TEXTURE_2D,n),this.context.texImage2D(this.context.TEXTURE_2D,0,l,r,i,0,s,u,null)),h}_getSupportedDepthFormats(){const e=[];return this.context instanceof WebGLRenderingContext&&!this.context.getExtension("WEBGL_depth_texture")||(e.push(this.context.DEPTH_COMPONENT,this.context.DEPTH_STENCIL),this.context instanceof WebGL2RenderingContext&&e.push(this.context.DEPTH_COMPONENT24,this.context.DEPTH24_STENCIL8)),e}}const o={colorFormat:6408,mipLevels:1,layout:t.mono,isStatic:!1,space:null,viewPixelHeight:0,viewPixelWidth:0,textureType:e.texture,radius:2,centralAngle:.78539,aspectRatio:2},a={layout:t.mono,invertStereo:!1,space:null,radius:2,centralAngle:.78539};class n extends s{constructor(e,t){super(),this._media=null!=t?t:null,this.isMediaLayer()?this.init=Object.assign(Object.assign({},a),e):this.init=Object.assign(Object.assign({},o),e),this.radius=this.init.radius,this.centralAngle=this.init.centralAngle,this.aspectRatio=this.init.aspectRatio,this.space=this.init.space,this.layout=this.init.layout;const r=i();this.init.transform?this.transform=new r.XRRigidTransform(e.transform.position,e.transform.orientation):this.transform=new r.XRRigidTransform({x:0,y:0,z:0,w:1}),this.isMediaLayer()||(this.isStatic=e.isStatic)}getTextureType(){return this.isMediaLayer()?e.texture:this.init.textureType}_deferredInitialize(){let e=this.determineLayoutAttribute(this.init.textureType,this.context,this.init.layout);this.layout=e,this.needsRedraw=!0}get colorTextures(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._colorTextures&&this._colorTextures.length||this._allocateColorTexturesInternal(this.getTextureType(),this.init),this._colorTextures}get depthStencilTextures(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._depthStencilTextures&&this._depthStencilTextures.length||this._allocateDepthStencilTexturesInternal(this.getTextureType(),this.init),this._depthStencilTextures}get colorTexturesMeta(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._colorTextures&&this._colorTextures.length||this._allocateColorTexturesInternal(this.getTextureType(),this.init),this._texturesMeta}get width(){return 2*this.radius*Math.PI*(this.centralAngle/(2*Math.PI))}get height(){return this.width/this.aspectRatio}}const h={colorFormat:6408,mipLevels:1,layout:t.mono,isStatic:!1,space:null,viewPixelHeight:0,viewPixelWidth:0,textureType:e.texture,radius:0,centralHorizontalAngle:6.28318,upperVerticalAngle:1.570795,lowerVerticalAngle:-1.570795},l={space:null,layout:t.mono,invertStereo:!1,radius:0,centralHorizontalAngle:6.28318,upperVerticalAngle:1.570795,lowerVerticalAngle:-1.570795};class u extends s{constructor(e,t){if(super(),this._media=null!=t?t:null,this.isMediaLayer()?this.init=Object.assign(Object.assign({},l),e):this.init=Object.assign(Object.assign({},h),e),!r(this.init.space))throw new TypeError("Equirect layer's space needs to be an XRReferenceSpace");this.radius=this.init.radius,this.centralHorizontalAngle=this.init.centralHorizontalAngle,this.upperVerticalAngle=this.init.upperVerticalAngle,this.lowerVerticalAngle=this.init.lowerVerticalAngle,this.space=this.init.space,this.layout=this.init.layout;const s=i();e.transform?this.transform=new s.XRRigidTransform(e.transform.position,e.transform.orientation):this.transform=new s.XRRigidTransform({x:0,y:0,z:0,w:1}),this.isMediaLayer()||(this.isStatic=e.isStatic)}getTextureType(){return this.isMediaLayer()?e.texture:this.init.textureType}_deferredInitialize(){let e=this.determineLayoutAttribute(this.init.textureType,this.context,this.init.layout);this.layout=e,this.needsRedraw=!0}get colorTextures(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._colorTextures&&this._colorTextures.length||this._allocateColorTexturesInternal(this.getTextureType(),this.init),this._colorTextures}get depthStencilTextures(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._depthStencilTextures&&this._depthStencilTextures.length||this._allocateDepthStencilTexturesInternal(this.getTextureType(),this.init),this._depthStencilTextures}get colorTexturesMeta(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._colorTextures&&this._colorTextures.length||this._allocateColorTexturesInternal(this.getTextureType(),this.init),this._texturesMeta}}const c={colorFormat:6408,mipLevels:1,layout:t.mono,isStatic:!1,space:null,viewPixelHeight:0,viewPixelWidth:0,textureType:e.texture,width:1,height:1},x={space:null,layout:t.mono,invertStereo:!1};class d extends s{constructor(e,t){super(),this._media=null!=t?t:null,this.isMediaLayer()?this.init=Object.assign(Object.assign({},x),e):this.init=Object.assign(Object.assign({},c),e),this.width=this.init.width,this.height=this.init.height,this.space=this.init.space,this.layout=this.init.layout;const r=i();this.init.transform?this.transform=new r.XRRigidTransform(e.transform.position,e.transform.orientation):this.transform=new r.XRRigidTransform({x:0,y:0,z:0,w:1}),this.isMediaLayer()||(this.isStatic=e.isStatic)}getTextureType(){return this.isMediaLayer()?e.texture:this.init.textureType}_deferredInitialize(){let e=this.determineLayoutAttribute(this.init.textureType,this.context,this.init.layout);this.layout=e,this.needsRedraw=!0}get colorTextures(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._colorTextures&&this._colorTextures.length||this._allocateColorTexturesInternal(this.getTextureType(),this.init),this._colorTextures}get depthStencilTextures(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._depthStencilTextures&&this._depthStencilTextures.length||this._allocateDepthStencilTexturesInternal(this.getTextureType(),this.init),this._depthStencilTextures}get colorTexturesMeta(){if(this.isMediaLayer())throw new Error("Media layers do not have associated textures");return this._colorTextures&&this._colorTextures.length||this._allocateColorTexturesInternal(this.getTextureType(),this.init),this._texturesMeta}}class f{constructor(e){if(this.session=e,this.session.ended)throw new Error("Session has ended")}createQuadLayer(e,r){if(this.session.ended)throw new Error("Session has ended");if(r.layout===t.default)throw new TypeError("Media Quad layer cannot be created with layout of default");let i=this.calculateAspectRatio(e,r.layout);void 0===r.width&&void 0===r.height&&(r.width=1),void 0===r.height&&(r.height=r.width/i),void 0===r.width&&(r.width=r.height/i);let s=new d(r,e);return s.needsRedraw=!1,s.initialize(this.session),s}createCylinderLayer(e,r){if(this.session.ended)throw new Error("Session has ended");if(r.layout===t.default)throw new TypeError("Media Cylinder layer cannot be created with layout of default");let i=this.calculateAspectRatio(e,r.layout);void 0===r.aspectRatio&&(r.aspectRatio=i);let s=new n(r,e);return s.needsRedraw=!1,s.initialize(this.session),s}createEquirectLayer(e,i){if(this.session.ended)throw new Error("Session has ended");if(i.layout===t.default)throw new TypeError("Media Equirect layer cannot be created with layout of default");if(!r(i.space))throw new Error("Media Equirect layer's space must be of type XRReferenceSpace");let s=new u(i,e);return s.needsRedraw=!1,s.initialize(this.session),s}calculateAspectRatio(e,r){let i=e.videoWidth,s=e.videoHeight;return r===t["stereo-left-right"]&&(i/=2),r===t["stereo-top-bottom"]&&(s/=2),i/s}}const T={textureType:e.texture,colorFormat:6408,depthFormat:6402,scaleFactor:1};class p extends s{constructor(e=T){super(),this.init=Object.assign(Object.assign({},T),e)}_allocateProjectionColorTextures(){let r=[],i=[];const s=()=>{r=[];for(let e of i)r.push(e.texture)};let o=this.session,a=o.internalViews;if(!a||0===a.length)return void console.warn("We can't allocate color textures without views");this.initializeIfNeeded();let n=o.getBaseLayer(),h=a.length,l=n.framebufferWidth*this.init.scaleFactor,u=n.framebufferHeight*this.init.scaleFactor;if(this.layout===t.mono||this.layout===t.default){if(this.init.textureType===e["texture-array"]){let t=this._createNewColorTexture(l,u,e["texture-array"],this.init.colorFormat,h);i=[t]}else for(let t of a){let t=this._createNewColorTexture(l,u,e.texture,this.init.colorFormat);i.push(t)}return s(),this._colorTexturesMeta=i,void(this._colorTextures=r)}if(this.layout===t["stereo-left-right"]){let e=this._createNewColorTexture(l*h,u,this.init.textureType,this.init.colorFormat);i=[e]}else if(this.layout===t["stereo-top-bottom"]){let e=this._createNewColorTexture(l,u*h,this.init.textureType,this.init.colorFormat);i=[e]}s(),this._colorTexturesMeta=i,this._colorTextures=r}_allocateProjectionDepthStencilTextures(){let r=this.session,i=r.internalViews;if(!i||0===i.length)return;if(0===this.init.depthFormat)return void(this._depthStencilTextures=[]);if(this.context instanceof WebGLRenderingContext){if(!this.context.getExtension("WEBGL_depth_texture"))return void(this._depthStencilTextures=[])}let s=[],o=[];const a=()=>{s=[];for(let e of o)s.push(e.texture)};this.initializeIfNeeded();let n=r.getBaseLayer(),h=i.length,l=n.framebufferWidth*this.init.scaleFactor,u=n.framebufferHeight*this.init.scaleFactor;if(this.layout===t.mono||this.layout===t.default){if(this.init.textureType===e["texture-array"]){let e=this._createNewDepthStencilTexture(l,u,this.init.textureType,this.init.depthFormat,h);o=[e]}else for(let e of i){let e=this._createNewDepthStencilTexture(l,u,this.init.textureType,this.init.depthFormat);o.push(e)}return a(),void(this._depthStencilTextures=s)}if(this.layout===t["stereo-left-right"]){let e=this._createNewDepthStencilTexture(l*h,u,this.init.textureType,this.init.depthFormat);o=[e]}else if(this.layout===t["stereo-top-bottom"]){let e=this._createNewDepthStencilTexture(l,u*h,this.init.textureType,this.init.depthFormat);o=[e]}a(),this._depthStencilTextures=s}get colorTextures(){return this._colorTextures&&this._colorTextures.length||this._allocateProjectionColorTextures(),this._colorTextures}get depthStencilTextures(){return void 0===this._depthStencilTextures&&this._allocateProjectionDepthStencilTextures(),this._depthStencilTextures||[]}get colorTexturesMeta(){return this._colorTextures&&this._colorTextures.length||this._allocateProjectionColorTextures(),this._colorTexturesMeta}getTextureType(){return this.init.textureType}_deferredInitialize(){this.isStatic=!1,this.init.depthFormat?this.ignoreDepthValues=!0:this.ignoreDepthValues=!1,this.fixedFoveation=0;let e=this.determineLayoutAttribute(this.init.textureType,this.context,t.default);this.layout=e,this.needsRedraw=!0;let r=this.determineMaximumScaleFactor(),i=Math.min(this.init.scaleFactor,r);this.init.scaleFactor=i}determineMaximumScaleFactor(){let e=this.session.getBaseLayer(this.context),r=e.framebufferWidth,i=e.framebufferHeight;this.layout===t["stereo-left-right"]&&(r*=2),this.layout===t["stereo-top-bottom"]&&(i*=2);let s=Math.max(r,i);return this.context.getParameter(this.context.MAX_TEXTURE_SIZE)/s}}const y=(e,r,i,s,o)=>{let a=0,n=0,h=r.width,l=r.height;i===t["stereo-left-right"]?(a=r.width*s/o,h=r.width/o):i===t["stereo-top-bottom"]&&(n=r.height*s/o,l=r.height/o),e.x=a,e.y=n,e.width=h,e.height=l},_=(e,t,r)=>{var i=e.createShader(r);if(e.shaderSource(i,t),e.compileShader(i),!e.getShaderParameter(i,e.COMPILE_STATUS))throw"could not compile shader:"+e.getShaderInfoLog(i);return i},g=(e,t,r)=>{const i=e.createProgram(),s=_(e,t,e.VERTEX_SHADER),o=_(e,r,e.FRAGMENT_SHADER);if(e.attachShader(i,s),e.attachShader(i,o),e.deleteShader(s),e.deleteShader(o),e.linkProgram(i),!e.getProgramParameter(i,e.LINK_STATUS))throw"program failed to link:"+e.getProgramInfoLog(i);return i},m=e=>{if(e instanceof WebGL2RenderingContext)return e;const t=e.getExtension("OES_vertex_array_object");if(!t)throw new Error("Cannot use VAOs.");return{bindVertexArray:t.bindVertexArrayOES,createVertexArray:t.createVertexArrayOES,deleteVertexArray:t.deleteVertexArrayOES,isVertexArray:t.isVertexArrayOES}},w=e=>e,E=w`
attribute vec2 a_position;
attribute vec2 a_texCoord;

varying vec2 v_texCoord;

void main() {
   // convert the rectangle from pixels to 0.0 to 1.0
   vec2 zeroToOne = a_position;

   // convert from 0->1 to 0->2
   vec2 zeroToTwo = zeroToOne * 2.0;

   // convert from 0->2 to -1->+1 (clipspace)
   vec2 clipSpace = zeroToTwo - 1.0;

   gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
`,v=w`
precision mediump float;

// our texture
uniform sampler2D u_image;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
   	vec4 tex = texture2D(u_image, v_texCoord);
	gl_FragColor = vec4(tex.rgb, tex.a);
}
`;class R{constructor(e,t){this.gl=t,this.layer=e,this.program=g(this.gl,E,v),this.programInfo={attribLocations:{a_position:this.gl.getAttribLocation(this.program,"a_position"),a_texCoord:this.gl.getAttribLocation(this.program,"a_texCoord")}},this._createVAOs()}render(t){let r=this.gl,i=t.getBaseLayer();r.viewport(0,0,i.framebufferWidth,i.framebufferHeight);this.layer.getTextureType()===e.texture?(r.bindTexture(r.TEXTURE_2D,this.layer.colorTextures[0]),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_S,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_WRAP_T,r.CLAMP_TO_EDGE),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MIN_FILTER,r.NEAREST),r.texParameteri(r.TEXTURE_2D,r.TEXTURE_MAG_FILTER,r.NEAREST)):r instanceof WebGL2RenderingContext&&r.bindTexture(r.TEXTURE_2D_ARRAY,this.layer.colorTextures[0]);for(let e of t.internalViews){let t=i.getViewport(e);r.viewport(t.x,t.y,t.width,t.height),this._shouldUseStereoTexturePoints()?this._renderInternalStereo(e):this._renderInternal()}}_renderInternal(){let e=this.gl;e.useProgram(this.program),this.vaoGl.bindVertexArray(this.vao);var t=e.TRIANGLES;e.drawArrays(t,0,6),this.vaoGl.bindVertexArray(null)}_renderInternalStereo(e){if("none"===e.eye)return this._renderInternal();let t=this.gl;this.vaoGl.bindVertexArray(this.vao),t.useProgram(this.program),this._setStereoTextureBuffer("right"===e.eye?1:0);var r=t.TRIANGLES;t.drawArrays(r,0,6),this.vaoGl.bindVertexArray(null)}_createVAOs(){this._createTextureUVs();let e=this.gl;this.vaoGl=m(e);let t=e.createBuffer();this.vao=this.vaoGl.createVertexArray(),this.vaoGl.bindVertexArray(this.vao),e.enableVertexAttribArray(this.programInfo.attribLocations.a_position),e.bindBuffer(e.ARRAY_BUFFER,t),((e,t,r,i,s)=>{var o=t,a=t+i,n=r,h=r+s;e.bufferData(e.ARRAY_BUFFER,new Float32Array([o,n,a,n,o,h,o,h,a,n,a,h]),e.DYNAMIC_DRAW)})(e,0,0,1,1);let r=e.FLOAT;e.vertexAttribPointer(this.programInfo.attribLocations.a_position,2,r,false,0,0),this.texcoordBuffer=e.createBuffer(),e.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord),e.bindBuffer(e.ARRAY_BUFFER,this.texcoordBuffer),e.bufferData(e.ARRAY_BUFFER,this.texturePoints,e.DYNAMIC_DRAW),e.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord,2,r,false,0,0),this.vaoGl.bindVertexArray(null)}_setStereoTextureBuffer(e){let t=this.gl;t.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord),t.bindBuffer(t.ARRAY_BUFFER,this.texcoordBuffer),t.bufferData(t.ARRAY_BUFFER,this.stereoTexturePoints[e],t.STATIC_DRAW);var r=t.FLOAT;t.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord,2,r,!1,0,0)}_createTextureUVs(){this.texturePoints=new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1]);const e={x:0,y:0,width:1,height:1};this._shouldUseStereoTexturePoints()&&(this.stereoTexturePoints=[],y(e,this.layer.colorTexturesMeta[0],this.layer.layout,0,2),this.stereoTexturePoints[0]=this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0],this.texturePoints,e),y(e,this.layer.colorTexturesMeta[0],this.layer.layout,1,2),this.stereoTexturePoints[1]=this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0],this.texturePoints,e))}_offsetTextureUVsByRect(e,t,r){const i=(r=null!=r?r:{x:0,y:0,width:e.width,height:e.height}).x/e.width,s=r.y/e.height,o=r.width/e.width,a=r.height/e.height,n=[];for(let e=0;e<t.length;e+=2){let r=t[e]*o+i,h=t[e+1]*a+s;n[e]=r,n[e+1]=h}return new Float32Array(n)}_shouldUseStereoTexturePoints(){return this.layer.layout===t["stereo-left-right"]||this.layer.layout===t["stereo-top-bottom"]}}const b=w`#version 300 es

in vec2 a_position;
in vec2 a_texCoord;

out vec2 v_texCoord;

void main() {
	// convert the rectangle from pixels to 0.0 to 1.0
	vec2 zeroToOne = a_position;

	// convert from 0->1 to 0->2
	vec2 zeroToTwo = zeroToOne * 2.0;
 
	// convert from 0->2 to -1->+1 (clipspace)
	vec2 clipSpace = zeroToTwo - 1.0;
 
	gl_Position = vec4(clipSpace * vec2(1, 1), 0, 1);
 
	// pass the texCoord to the fragment shader
	// The GPU will interpolate this value between points.
	v_texCoord = a_texCoord;
}
`,A=w`#version 300 es
precision mediump float;
precision mediump int;
precision mediump sampler2DArray;

uniform sampler2DArray u_image;
uniform int u_layer;

in vec2 v_texCoord;

out vec4 fragColor;

void main() {
	vec4 tex = texture(u_image, vec3(v_texCoord.x, v_texCoord.y, u_layer));
 	fragColor = vec4(tex.rgb, tex.a);
}

`;class S extends R{constructor(e,t){super(e,t),this.program=g(this.gl,b,A),this._createVAOs(),this.u_layerInfo=this.gl.getUniformLocation(this.program,"u_layer")}render(t){let r=this.gl;if(this.layer.getTextureType()===e.texture)throw new Error("Using texture array projection renderer on a layer without texture array.");let i=t.getBaseLayer();r.bindTexture(r.TEXTURE_2D_ARRAY,this.layer.colorTextures[0]),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MAG_FILTER,r.LINEAR),r.texParameteri(r.TEXTURE_2D_ARRAY,r.TEXTURE_MIN_FILTER,r.LINEAR);for(let e of t.internalViews){let s=t.getViewIndex(e),o=i.getViewport(e);r.viewport(o.x,o.y,o.width,o.height),this._renderInternal(s)}}_renderInternal(e=0){let t=this.gl;t.useProgram(this.program),t.bindVertexArray(this.vao),t.uniform1i(this.u_layerInfo,e);var r=t.TRIANGLES;t.drawArrays(r,0,6),t.bindVertexArray(null)}}const P=(t,r)=>t.getTextureType()===e["texture-array"]&&r instanceof WebGL2RenderingContext?new S(t,r):new R(t,r);var L="undefined"!=typeof Float32Array?Float32Array:Array;function M(){var e=new L(16);return L!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function C(e,t,r){var i=t[0],s=t[1],o=t[2],a=t[3],n=t[4],h=t[5],l=t[6],u=t[7],c=t[8],x=t[9],d=t[10],f=t[11],T=t[12],p=t[13],y=t[14],_=t[15],g=r[0],m=r[1],w=r[2],E=r[3];return e[0]=g*i+m*n+w*c+E*T,e[1]=g*s+m*h+w*x+E*p,e[2]=g*o+m*l+w*d+E*y,e[3]=g*a+m*u+w*f+E*_,g=r[4],m=r[5],w=r[6],E=r[7],e[4]=g*i+m*n+w*c+E*T,e[5]=g*s+m*h+w*x+E*p,e[6]=g*o+m*l+w*d+E*y,e[7]=g*a+m*u+w*f+E*_,g=r[8],m=r[9],w=r[10],E=r[11],e[8]=g*i+m*n+w*c+E*T,e[9]=g*s+m*h+w*x+E*p,e[10]=g*o+m*l+w*d+E*y,e[11]=g*a+m*u+w*f+E*_,g=r[12],m=r[13],w=r[14],E=r[15],e[12]=g*i+m*n+w*c+E*T,e[13]=g*s+m*h+w*x+E*p,e[14]=g*o+m*l+w*d+E*y,e[15]=g*a+m*u+w*f+E*_,e}function F(e,t){var r=t[0],i=t[1],s=t[2],o=t[3],a=r+r,n=i+i,h=s+s,l=r*a,u=i*a,c=i*n,x=s*a,d=s*n,f=s*h,T=o*a,p=o*n,y=o*h;return e[0]=1-c-f,e[1]=u+y,e[2]=x-p,e[3]=0,e[4]=u-y,e[5]=1-l-f,e[6]=d+T,e[7]=0,e[8]=x+p,e[9]=d-T,e[10]=1-l-c,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function I(){var e=new L(2);return L!=Float32Array&&(e[0]=0,e[1]=0),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)}),I();const D=e=>e,U=D`
attribute vec4 a_position;
attribute vec2 a_texCoord;

uniform mat4 u_matrix;
uniform mat4 u_projectionMatrix;

varying vec2 v_texCoord;

void main() {
  // Multiply the position by the matrix.
  gl_Position = u_projectionMatrix * u_matrix * a_position;

   // pass the texCoord to the fragment shader
   // The GPU will interpolate this value between points.
   v_texCoord = a_texCoord;
}
`,B=D`
precision mediump float;

// our texture
uniform sampler2D u_image;

// the texCoords passed in from the vertex shader.
varying vec2 v_texCoord;

void main() {
   	vec4 tex = texture2D(u_image, v_texCoord);
	gl_FragColor = vec4(tex.rgb, tex.a);
	// gl_FragColor = vec4(1.0, 0, 0, 1.0);
}
`,O=D`#version 300 es

in vec4 a_position;
in vec2 a_texCoord;

uniform mat4 u_matrix;
uniform mat4 u_projectionMatrix;

out vec2 v_texCoord;

void main() {
	// Multiply the position by the matrix.
    gl_Position = u_projectionMatrix * u_matrix * a_position;
 
	// pass the texCoord to the fragment shader
	// The GPU will interpolate this value between points.
	v_texCoord = a_texCoord;
}
`,N=D`#version 300 es
precision mediump float;
precision mediump int;
precision mediump sampler2DArray;

uniform sampler2DArray u_image;
uniform int u_layer;

in vec2 v_texCoord;

out vec4 fragColor;

void main() {
	vec4 tex = texture(u_image, vec3(v_texCoord.x, v_texCoord.y, u_layer));
 	fragColor = vec4(tex.rgb, tex.a);
}

`;class V{constructor(t,r){this.usesTextureArrayShaders=!1,this.gl=r,this.layer=t;let i=this.gl;this.transformMatrix=M(),r instanceof WebGL2RenderingContext&&this.layer.getTextureType()===e["texture-array"]&&(this.usesTextureArrayShaders=!0),this.usesTextureArrayShaders?this.program=g(i,O,N):this.program=g(i,U,B),this.programInfo={attribLocations:{a_position:i.getAttribLocation(this.program,"a_position"),a_texCoord:i.getAttribLocation(this.program,"a_texCoord")},uniformLocations:{u_matrix:i.getUniformLocation(this.program,"u_matrix"),u_projectionMatrix:i.getUniformLocation(this.program,"u_projectionMatrix")}},this.usesTextureArrayShaders&&(this.programInfo.uniformLocations.u_layer=i.getUniformLocation(this.program,"u_layer"))}initialize(){let t=this.gl;this.layer.isMediaLayer()&&(this.mediaTexture=t.createTexture(),this.mediaTexturePolyfill={texture:this.mediaTexture,textureFormat:t.RGBA,width:this.layer.media.videoWidth,height:this.layer.media.videoHeight,type:e.texture},t.bindTexture(t.TEXTURE_2D,this.mediaTexture),t.texImage2D(t.TEXTURE_2D,0,t.RGBA,this.layer.media.videoWidth,this.layer.media.videoHeight,0,t.RGBA,t.UNSIGNED_BYTE,null),t.bindTexture(t.TEXTURE_2D,null)),this._createVAOs()}render(e,r){let i=this.gl,s=e.getBaseLayer(),o=r.getViewerPose(e.getReferenceSpace());for(let a of o.views){let o=s.getViewport(a);if(i.viewport(o.x,o.y,o.width,o.height),i.activeTexture(i.TEXTURE0),this.usesTextureArrayShaders){if(i instanceof WebGLRenderingContext)throw new Error("This should never happen; texture-arrays only supported on WebGL2.");if(this.layer.isMediaLayer())throw new Error("This should never happen. Media layers should never be created with texture-array");i.bindTexture(i.TEXTURE_2D_ARRAY,this.layer.colorTextures[0]),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D_ARRAY,i.TEXTURE_MIN_FILTER,i.LINEAR);let s=0;if(this.layer.layout===t.stereo)switch(a.eye){case"right":s=1}this._shouldUseStereoTexturePoints()?this._renderInternalStereo(e,r,a,s):this._renderInternal(e,r,a,s)}else{if(this.layer.isMediaLayer())i.bindTexture(i.TEXTURE_2D,this.mediaTexture),i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL,!0),i.texSubImage2D(i.TEXTURE_2D,0,0,0,this.layer.media.videoWidth,this.layer.media.videoHeight,i.RGBA,i.UNSIGNED_BYTE,this.layer.media);else if(this.layer.layout===t.stereo)switch(a.eye){case"right":i.bindTexture(i.TEXTURE_2D,this.layer.colorTextures[1]);break;default:i.bindTexture(i.TEXTURE_2D,this.layer.colorTextures[0])}else i.bindTexture(i.TEXTURE_2D,this.layer.colorTextures[0]);i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_S,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_WRAP_T,i.CLAMP_TO_EDGE),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.NEAREST),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.NEAREST),this._shouldUseStereoTexturePoints()?this._renderInternalStereo(e,r,a):this._renderInternal(e,r,a)}}}createPositionPoints(){return new Float32Array([])}createTextureUVs(){return new Float32Array([])}_offsetTextureUVsByRect(e,t,r){const i=(r=null!=r?r:{x:0,y:0,width:e.width,height:e.height}).x/e.width,s=r.y/e.height,o=r.width/e.width,a=r.height/e.height,n=[];for(let e=0;e<t.length;e+=2){let r=t[e]*o+i,h=t[e+1]*a+s;n[e]=r,n[e+1]=h}return new Float32Array(n)}_shouldUseStereoTexturePoints(){return this.layer.layout===t["stereo-left-right"]||this.layer.layout===t["stereo-top-bottom"]}_setStereoTextureBuffer(e){let t=this.gl;t.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord),t.bindBuffer(t.ARRAY_BUFFER,this.texcoordBuffer),t.bufferData(t.ARRAY_BUFFER,this.stereoTexturePoints[e],t.STATIC_DRAW);var r=t.FLOAT;t.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord,2,r,!1,0,0)}_recalculateVertices(){this.positionPoints=this.createPositionPoints(),this.texturePoints=this.createTextureUVs();const e={x:0,y:0,width:1,height:1};if(this._shouldUseStereoTexturePoints()){if(this.stereoTexturePoints=[],this.layer.isMediaLayer())return y(e,this.mediaTexturePolyfill,this.layer.layout,0,2),this.stereoTexturePoints[0]=this._offsetTextureUVsByRect(this.mediaTexturePolyfill,this.texturePoints,e),y(e,this.mediaTexturePolyfill,this.layer.layout,1,2),void(this.stereoTexturePoints[1]=this._offsetTextureUVsByRect(this.mediaTexturePolyfill,this.texturePoints,e));y(e,this.layer.colorTexturesMeta[0],this.layer.layout,0,2),this.stereoTexturePoints[0]=this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0],this.texturePoints,e),y(e,this.layer.colorTexturesMeta[0],this.layer.layout,1,2),this.stereoTexturePoints[1]=this._offsetTextureUVsByRect(this.layer.colorTexturesMeta[0],this.texturePoints,e)}}_createVAOs(){this._recalculateVertices();let e=this.gl;this.vaoGl=m(e);let t=e.createBuffer();this.vao=this.vaoGl.createVertexArray(),this.vaoGl.bindVertexArray(this.vao),e.enableVertexAttribArray(this.programInfo.attribLocations.a_position),e.bindBuffer(e.ARRAY_BUFFER,t);const r=this.positionPoints;e.bufferData(e.ARRAY_BUFFER,r,e.STATIC_DRAW);var i=3,s=e.FLOAT,o=!1,a=0,n=0;e.vertexAttribPointer(this.programInfo.attribLocations.a_position,i,s,o,a,n),e.enableVertexAttribArray(this.programInfo.attribLocations.a_texCoord),this.texcoordBuffer=e.createBuffer(),e.bindBuffer(e.ARRAY_BUFFER,this.texcoordBuffer),e.bufferData(e.ARRAY_BUFFER,this.texturePoints,e.STATIC_DRAW);i=2,s=e.FLOAT,o=!1,a=0,n=0;e.vertexAttribPointer(this.programInfo.attribLocations.a_texCoord,i,s,o,a,n),this.vaoGl.bindVertexArray(null)}_renderInternal(e,t,r,i){let s=this.gl;s.useProgram(this.program),this.vaoGl.bindVertexArray(this.vao),this.usesTextureArrayShaders&&s.uniform1i(this.programInfo.uniformLocations.u_layer,i),this._setTransformMatrix(e,t,r),s.uniformMatrix4fv(this.programInfo.uniformLocations.u_matrix,!1,this.transformMatrix),s.uniformMatrix4fv(this.programInfo.uniformLocations.u_projectionMatrix,!1,r.projectionMatrix);var o=s.TRIANGLES,a=this.positionPoints.length/3;s.drawArrays(o,0,a),this.vaoGl.bindVertexArray(null)}_renderInternalStereo(e,t,r,i){if("none"===r.eye)return this._renderInternal(e,t,r);let s=this.gl;this.vaoGl.bindVertexArray(this.vao),s.useProgram(this.program),this._setStereoTextureBuffer("right"===r.eye?1:0),this.usesTextureArrayShaders&&s.uniform1i(this.programInfo.uniformLocations.u_layer,i),this._setTransformMatrix(e,t,r),s.uniformMatrix4fv(this.programInfo.uniformLocations.u_matrix,!1,this.transformMatrix),s.uniformMatrix4fv(this.programInfo.uniformLocations.u_projectionMatrix,!1,r.projectionMatrix);var o=s.TRIANGLES,a=this.positionPoints.length/3;s.drawArrays(o,0,a),this.vaoGl.bindVertexArray(null)}_setTransformMatrix(e,t,r){let i=t.getPose(this.layer.space,e.getReferenceSpace());C(this.transformMatrix,i.transform.matrix,this.layer.transform.matrix),C(this.transformMatrix,r.transform.inverse.matrix,this.transformMatrix)}}class X extends V{constructor(e,t){super(e,t),this.initialize()}createPositionPoints(){const e=this.layer.width,t=this.layer.height;return new Float32Array([-e,-t,0,e,-t,0,-e,t,0,-e,t,0,e,-t,0,e,t,0])}createTextureUVs(){return new Float32Array([0,0,1,0,0,1,0,1,1,0,1,1])}}class G extends V{constructor(e,t){super(e,t),this.segments=16,this.initialize()}createPositionPoints(){const e=[],t=this.layer.centralAngle,r=this.layer.height,i=this.layer.radius,s=t/this.segments,o=Math.PI/2-t/2,a=[],n=I();n[0]=i*Math.cos(o),n[1]=-i*Math.sin(o),a.push(n);for(let e=0;e<this.segments;e++){const t=I();t[0]=i*Math.cos(o+s*(e+1)),t[1]=-i*Math.sin(o+s*(e+1)),a.push(t)}a.reverse();for(let t=0;t<this.segments;t++){const i=a[t],s=a[t+1];e.push(i[0],-r/2,i[1]),e.push(s[0],-r/2,s[1]),e.push(i[0],r/2,i[1]),e.push(i[0],r/2,i[1]),e.push(s[0],-r/2,s[1]),e.push(s[0],r/2,s[1])}return new Float32Array(e)}createTextureUVs(){let e=[];const t=1/this.segments;for(let r=0;r<this.segments;r++){let i=t*r,s=t*(r+1);e.push(i,0),e.push(s,0),e.push(i,1),e.push(i,1),e.push(s,0),e.push(s,1)}return new Float32Array(e)}}class W extends V{constructor(e,t){super(e,t),this.segmentsPerAxis=40,this.initialize()}createPositionPoints(){const e=[],t=this.layer.radius||1,r=this.layer.centralHorizontalAngle,i=this.layer.upperVerticalAngle+Math.PI/2,s=this.layer.lowerVerticalAngle+Math.PI/2,o=Math.PI/2-r/2,a=o+r,n=s-i,h=a-o,l=[];for(let e=0;e<=this.segmentsPerAxis;e++)for(let r=0;r<=this.segmentsPerAxis;r++){let s=t,o=a-h*(r/this.segmentsPerAxis),u=n*(e/this.segmentsPerAxis)+i;const c=Math.cos(o)*Math.sin(u),x=Math.cos(u),d=-Math.sin(o)*Math.sin(u);l.push([s*c,s*x,s*d])}const u=this.segmentsPerAxis+1;for(let t=0;t<this.segmentsPerAxis;t++)for(let r=0;r<this.segmentsPerAxis;r++)e.push(...l[r*u+t]),e.push(...l[r*u+t+1]),e.push(...l[(r+1)*u+t]),e.push(...l[(r+1)*u+t]),e.push(...l[r*u+t+1]),e.push(...l[(r+1)*u+t+1]);return new Float32Array(e)}createTextureUVs(){const e=[],t=[];for(let e=0;e<=this.segmentsPerAxis;e++)for(let r=0;r<=this.segmentsPerAxis;r++){const i=r/this.segmentsPerAxis,s=e/this.segmentsPerAxis;t.push([i,s])}const r=this.segmentsPerAxis+1;for(let i=0;i<this.segmentsPerAxis;i++)for(let s=0;s<this.segmentsPerAxis;s++)e.push(...t[s*r+i]),e.push(...t[s*r+i+1]),e.push(...t[(s+1)*r+i]),e.push(...t[(s+1)*r+i]),e.push(...t[s*r+i+1]),e.push(...t[(s+1)*r+i+1]);return new Float32Array(e)}}const H={colorFormat:6408,mipLevels:1,layout:t.mono,isStatic:!1,space:null,viewPixelHeight:0,viewPixelWidth:0};class j extends s{constructor(e=H){if(super(),!r(e.space))throw new TypeError("XRCubeLayer's space needs to be an XRReferenceSpace");switch(this.init=Object.assign(Object.assign({},H),e),this.space=this.init.space,this.isStatic=this.init.isStatic,this.init.orientation?this.orientation=DOMPointReadOnly.fromPoint(this.init.orientation):this.orientation=new DOMPointReadOnly,this.init.layout){case t.default:case t["stereo-left-right"]:case t["stereo-top-bottom"]:throw new TypeError("Invalid layout format for XRCubeLayer")}this.layout=this.init.layout,this.needsRedraw=!0}initialize(e,t){super.initialize(e,t),this._allocateColorTexturesInternal(),this._allocateDepthStencilTexturesInternal()}_allocateColorTexturesInternal(){if(this._colorTextures=[],this._texturesMeta=[],this.layout===t.mono){const e=this._createCubeColorTexture();return this._texturesMeta.push(e),void this._colorTextures.push(e.texture)}{const e=this._createCubeColorTexture(),t=this._createCubeColorTexture();return this._texturesMeta.push(e,t),void this._colorTextures.push(e.texture,t.texture)}}_allocateDepthStencilTexturesInternal(){if(this._depthStencilTextures=[],this.init.depthFormat){if(this.context instanceof WebGLRenderingContext){if(!this.context.getExtension("WEBGL_depth_texture"))throw new TypeError("Depth textures not supported in the current context")}if(this.layout!==t.mono){const e=this._createCubeDepthTexture(),t=this._createCubeDepthTexture();return void this._depthStencilTextures.push(e.texture,t.texture)}{const e=this._createCubeDepthTexture();this._depthStencilTextures.push(e.texture)}}}_createCubeColorTexture(){let t=this.context.createTexture(),r={width:this.init.viewPixelWidth,height:this.init.viewPixelHeight,layers:1,type:e.texture,textureFormat:this.init.colorFormat,texture:t};this.context.bindTexture(this.context.TEXTURE_CUBE_MAP,t);for(let e=0;e<6;e++)this.context.texImage2D(this.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,r.textureFormat,r.width,r.height,0,r.textureFormat,this.context.UNSIGNED_BYTE,null);return r}_createCubeDepthTexture(){let t=this.context.createTexture(),r={width:this.init.viewPixelWidth,height:this.init.viewPixelHeight,layers:1,type:e.texture,textureFormat:this.init.depthFormat,texture:t};this.context.bindTexture(this.context.TEXTURE_CUBE_MAP,t);let i=this.init.depthFormat;this.context instanceof WebGL2RenderingContext&&i===this.context.DEPTH_COMPONENT&&(i=this.context.DEPTH_COMPONENT24);for(let e=0;e<6;e++)this.context.texImage2D(this.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,0,i,r.width,r.height,0,r.textureFormat,this.context.UNSIGNED_INT,null);return r}getTextureType(){return e.texture}}const z=e=>e,q=z`
attribute vec4 a_position;
uniform mat4 u_projectionMatrix;
uniform mat4 u_matrix;
varying vec3 v_normal;

void main() {
   gl_Position = u_projectionMatrix * u_matrix * a_position;

   v_normal = normalize(a_position.xyz);
}
`,Y=z`
precision mediump float;

varying vec3 v_normal;

uniform samplerCube u_texture;

void main() {
   gl_FragColor = textureCube(u_texture, normalize(v_normal));
}
`;class k{constructor(e,t){this.layer=e,this.gl=t,this.transformMatrix=M(),this.program=g(t,q,Y),this.programInfo={attribLocations:{a_position:t.getAttribLocation(this.program,"a_position")},uniformLocations:{u_matrix:t.getUniformLocation(this.program,"u_matrix"),u_texture:t.getUniformLocation(this.program,"u_texture"),u_projectionMatrix:t.getUniformLocation(this.program,"u_projectionMatrix")}}}render(e,r){let i=this.gl,s=e.getBaseLayer(),o=r.getViewerPose(e.getReferenceSpace());for(let e of o.views){let r=s.getViewport(e);if(i.viewport(r.x,r.y,r.width,r.height),i.activeTexture(i.TEXTURE0),this.layer.layout===t.stereo){const t="right"===e.eye?1:0;i.bindTexture(i.TEXTURE_CUBE_MAP,this.layer.colorTextures[t])}else i.bindTexture(i.TEXTURE_CUBE_MAP,this.layer.colorTextures[0]);i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_CUBE_MAP,i.TEXTURE_MIN_FILTER,i.LINEAR),this._renderInternal(this.layer.orientation,e)}}createPositionPoints(){const e=.5;return new Float32Array([-e,-e,-e,-e,e,-e,e,-e,-e,-e,e,-e,e,e,-e,e,-e,-e,-e,-e,e,e,-e,e,-e,e,e,-e,e,e,e,-e,e,e,e,e,-e,e,-e,-e,e,e,e,e,-e,-e,e,e,e,e,e,e,e,-e,-e,-e,-e,e,-e,-e,-e,-e,e,-e,-e,e,e,-e,-e,e,-e,e,-e,-e,-e,-e,-e,e,-e,e,-e,-e,-e,e,-e,e,e,-e,e,-e,e,-e,-e,e,e,-e,e,-e,e,e,-e,e,e,e,-e,e,e,e])}_renderInternal(e,t){let r=this.gl;this.positionBuffer||(this._initBuffers(),this._setBuffers(!0)),r.useProgram(this.program),this._setBuffers(),F(this.transformMatrix,[e.x,e.y,e.z,e.w]),this._poseOrientationMatrix||(this._poseOrientationMatrix=M()),F(this._poseOrientationMatrix,[t.transform.inverse.orientation.x,t.transform.inverse.orientation.y,t.transform.inverse.orientation.z,t.transform.inverse.orientation.w]),C(this.transformMatrix,this.transformMatrix,this._poseOrientationMatrix),r.uniformMatrix4fv(this.programInfo.uniformLocations.u_matrix,!1,this.transformMatrix),r.uniformMatrix4fv(this.programInfo.uniformLocations.u_projectionMatrix,!1,t.projectionMatrix),r.uniform1i(this.programInfo.uniformLocations.u_texture,0);var i=r.TRIANGLES,s=this.positionPoints.length/3;r.drawArrays(i,0,s)}_initBuffers(){let e=this.gl;this.positionBuffer=e.createBuffer()}_recalculateVertices(){this.positionPoints=this.createPositionPoints()}_setBuffers(e){e&&this._recalculateVertices();let t=this.gl;if(t.enableVertexAttribArray(this.programInfo.attribLocations.a_position),t.bindBuffer(t.ARRAY_BUFFER,this.positionBuffer),e){const e=this.positionPoints;t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)}var r=t.FLOAT;t.vertexAttribPointer(this.programInfo.attribLocations.a_position,3,r,!1,0,0)}}class Q{constructor(){this.mode="inline",this.layers=[],this.views=[],this.initializedViews=!1,this.isPolyfillActive=!1,this.taskQueue=[]}requestAnimationFrame(t){this.injectedFrameCallback||(this.injectedFrameCallback=(r,i)=>{let s=this.context;if(!this.initializedViews&&this.referenceSpace){let e=i.getViewerPose(this.referenceSpace);e&&(this.views=e.views,this.initializedViews=!0)}if(this.isPolyfillActive){this.tempFramebuffer||(this.tempFramebuffer=s.createFramebuffer()),s.bindFramebuffer(s.FRAMEBUFFER,this.tempFramebuffer);for(let t of this.layers)if(t instanceof p)for(let r=0;r<t.colorTextures.length;r++){t.colorTexturesMeta[r].type===e["texture-array"]||(s.framebufferTexture2D(s.FRAMEBUFFER,s.COLOR_ATTACHMENT0,s.TEXTURE_2D,t.colorTextures[r],0),t.depthStencilTextures&&r<t.depthStencilTextures.length?s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,t.depthStencilTextures[r],0):s.framebufferTexture2D(s.FRAMEBUFFER,s.DEPTH_ATTACHMENT,s.TEXTURE_2D,null,0),s.clear(s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT))}s.bindFramebuffer(s.FRAMEBUFFER,this.getBaseLayer().framebuffer),s.clear(s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT)}if(t(r,i),this.isPolyfillActive&&this.initializedViews){let e=s.isEnabled(s.BLEND),t=s.isEnabled(s.DEPTH_TEST),r=s.isEnabled(s.CULL_FACE);s.bindFramebuffer(s.FRAMEBUFFER,this.getBaseLayer().framebuffer),s.enable(s.BLEND),s.disable(s.DEPTH_TEST),s.blendFunc(s.SRC_ALPHA,s.ONE_MINUS_SRC_ALPHA);for(let e of this.layers)if(this.renderers||(this.renderers=new WeakMap),e instanceof p){this.renderers.has(e)||this.renderers.set(e,P(e,this.context));this.renderers.get(e).render(this)}else if(e instanceof d){this.renderers.has(e)||this.renderers.set(e,new X(e,this.context));this.renderers.get(e).render(this,i)}else if(e instanceof n){this.renderers.has(e)||this.renderers.set(e,new G(e,this.context));this.renderers.get(e).render(this,i)}else if(e instanceof u){this.renderers.has(e)||this.renderers.set(e,new W(e,this.context));this.renderers.get(e).render(this,i)}else if(e instanceof j){this.renderers.has(e)||this.renderers.set(e,new k(e,this.context));this.renderers.get(e).render(this,i)}else{const t=e;if(null===t.framebuffer)continue;s instanceof WebGL2RenderingContext?(s.bindFramebuffer(s.READ_FRAMEBUFFER,t.framebuffer),s.bindFramebuffer(s.DRAW_FRAMEBUFFER,this.getBaseLayer().framebuffer),s.blitFramebuffer(0,0,t.framebufferWidth,t.framebufferHeight,0,0,this.getBaseLayer().framebufferWidth,this.getBaseLayer().framebufferHeight,s.COLOR_BUFFER_BIT|s.DEPTH_BUFFER_BIT,s.LINEAR)):console.warn("GL blitFramebuffer is not supported on WebGL1, so XRWebGLLayers may not show up properly when polyfilled.")}for(e||s.disable(s.BLEND),t&&s.enable(s.DEPTH_TEST),r&&s.enable(s.CULL_FACE);this.taskQueue.length>0;){this.taskQueue.shift()()}}}),this._requestAnimationFrame(this.injectedFrameCallback)}updateRenderState(e){if(this.existingBaseLayer=e.baseLayer,!e.layers)return this._updateRenderState(e);this.layers=e.layers||[],this.activeRenderState=e;let t,r=Object.assign({},e);delete r.layers;for(let e of this.layers)if(e instanceof s){t=e.getContext();break}if(!t&&!this.context){console.log("No existing context! Have the session make one");const e=document.createElement("canvas");if(t=e.getContext("webgl2",{xrCompatible:!0}),t||(t=e.getContext("webgl",{xrCompatible:!0})),!t)throw new Error("No webGL support detected.");function i(){t.canvas.width=t.canvas.clientWidth*window.devicePixelRatio,t.canvas.height=t.canvas.clientHeight*window.devicePixelRatio}document.body.appendChild(t.canvas),window.addEventListener("resize",i),i()}return this.createInternalLayer(t),this.isPolyfillActive=!0,this._updateRenderState(Object.assign(Object.assign({},r),{baseLayer:this.internalLayer}))}initializeSession(e){this.mode=e,this.requestReferenceSpace("local").then((e=>{this.referenceSpace=e})).catch((e=>{})),this.requestReferenceSpace("viewer").then((e=>{this.viewerSpace=e}))}getBaseLayer(e){return this.internalLayer||this.existingBaseLayer||!e||this.createInternalLayer(e),this.internalLayer||this.existingBaseLayer}getReferenceSpace(){return this.referenceSpace?this.referenceSpace:this.viewerSpace}getViewerSpace(){return this.viewerSpace}queueTask(e){this.taskQueue.push(e)}get renderState(){return this.activeRenderState?this.activeRenderState:this._renderState}get internalViews(){return this.views}getViewIndex(e){for(let t=0;t<this.views.length;t++){let r=this.views[t];if(e.eye===r.eye&&e.recommendedViewportScale===r.recommendedViewportScale)return t}return-1}createInternalLayer(e){if(!e&&this.internalLayer)return this.internalLayer;if(e===this.context&&this.internalLayer)return this.internalLayer;const t=i();return this.internalLayer=new t.XRWebGLLayer(this,e),this.setContext(e),this.internalLayer}setContext(e){this.context=e,this.tempFramebuffer=e.createFramebuffer(),this.renderers=new WeakMap}}class K{constructor(){this.viewport={x:0,y:0,width:0,height:0}}}class Z{constructor(e,t){this.session=e,this.context=t,this.subImageCache=new J}createProjectionLayer(e=T){const t=new p(e);if(this.session.ended)throw new Error("Session has ended");if(this.context.isContextLost())throw new Error("context is lost");return t.initialize(this.session,this.context),t}createQuadLayer(e=c){if(this.session.ended)throw new Error("Session has ended");if(this.context.isContextLost())throw new Error("context is lost");if(e.layout===t.default)throw new TypeError("Trying to create a quad layer with default layout");const r=new d(e);return r.initialize(this.session,this.context),r}createCylinderLayer(e=o){if(this.session.ended)throw new Error("Session has ended");if(this.context.isContextLost())throw new Error("context is lost");if(e.layout===t.default)throw new TypeError("Cylinder Layer cannot have a default layout");const r=new n(e);return r.initialize(this.session,this.context),r}createEquirectLayer(e=h){if(this.session.ended)throw new Error("Session has ended");if(this.context.isContextLost())throw new Error("context is lost");if(e.layout===t.default)throw new TypeError("Equirect Layer cannot have a default layout");if(!r(e.space))throw new TypeError("Equirect layer requires an XRReferenceSpace");let i=new u(e);return i.initialize(this.session,this.context),i}createCubeLayer(e){if(this.session.ended)throw new Error("Session has ended");if(this.context.isContextLost())throw new Error("context is lost");if(!(this.context instanceof WebGL2RenderingContext))throw new Error("XRCubeLayer only work on WebGL2");if(!r(e.space))throw new TypeError("XRCubeLayer requires a space of type XRReferenceSpace");let t=new j(e);return t.initialize(this.session,this.context),t}getSubImage(r,i,s="none"){let o=this.subImageCache.tryGetCachedSubImage(this.context,r,s);if(o)return o;let a=new K;if(r instanceof p)throw new TypeError;if(r.layout===t.default)throw new TypeError;if(!this.validateStateofSubImageCreation(r,i))throw new Error("Invalid state for subimage creation");let n=0;if(r.layout===t.stereo){if("none"===s)throw new TypeError;"right"===s&&(n=1)}r.getTextureType()===e["texture-array"]?a.imageIndex=n:a.imageIndex=0;let h=0;r.getTextureType()===e.texture?(a.colorTexture=r.colorTextures[n],h=n):(a.colorTexture=r.colorTextures[0],h=0),r.depthStencilTextures&&r.depthStencilTextures.length?r.getTextureType()===e.texture?a.depthStencilTexture=r.depthStencilTextures[n]:a.depthStencilTexture=r.depthStencilTextures[0]:a.depthStencilTexture=null;const l=r.colorTexturesMeta[h];a.textureWidth=l.width,a.textureHeight=l.height;let u=1;return r.layout!==t["stereo-left-right"]&&r.layout!==t["stereo-top-bottom"]||(u=2),y(a.viewport,l,r.layout,n,u),this.session.queueTask((()=>{r.needsRedraw=!1})),this.subImageCache.cacheSubImage(a,this.context,r,s),a}getViewSubImage(r,i){let s=this.subImageCache.tryGetCachedViewSubImage(this.context,r,i);if(s)return s;let o=new K,a=this.session;if(!a.internalViews||!a.internalViews.length)return console.warn("Tried to get view sub image before we have any views"),o;let n=a.getViewIndex(i),h=0;return r.getTextureType()===e["texture-array"]?o.imageIndex=n:o.imageIndex=0,r.layout===t.default&&r.getTextureType()===e.texture?(o.colorTexture=r.colorTextures[n],h=n):(o.colorTexture=r.colorTextures[0],h=0),0===r.depthStencilTextures.length?o.depthStencilTexture=null:r.layout===t.default&&r.getTextureType()===e.texture?o.depthStencilTexture=r.depthStencilTextures[n]:o.depthStencilTexture=r.depthStencilTextures[0],o.textureWidth=r.colorTexturesMeta[h].width,o.textureHeight=r.colorTexturesMeta[h].height,y(o.viewport,r.colorTexturesMeta[h],r.layout,n,a.internalViews.length),r.needsRedraw=!1,this.subImageCache.cacheViewSubImage(o,this.context,r,i),o}validateStateofSubImageCreation(e,t){return t.session===e.session&&(this.session===e.session&&(this.context===e.context&&(!(!e.colorTextures||!e.colorTextures.length)&&(!e.isStatic||!1!==e.needsRedraw))))}}class J{constructor(){this.cache=new Map,this.viewCache=new Map}cacheSubImage(e,t,r,i){let s=new Map;s.set(i,e);let o=new Map;o.set(r,s),this.cache.set(t,o)}tryGetCachedSubImage(e,t,r){var i,s;return null===(s=null===(i=this.cache.get(e))||void 0===i?void 0:i.get(t))||void 0===s?void 0:s.get(r)}cacheViewSubImage(e,t,r,i){let s=new Map;s.set(i,e);let o=new Map;o.set(r,s),this.viewCache.set(t,o)}tryGetCachedViewSubImage(e,t,r){var i,s;return null===(s=null===(i=this.viewCache.get(e))||void 0===i?void 0:i.get(t))||void 0===s?void 0:s.get(r)}}return class{constructor(){this.injected=!1;const e=i();this._injectPolyfill(e)}_injectPolyfill(e){if(!("xr"in e.navigator))throw new Error("WebXR Layers polyfill requires WebXR support.");!0===this.injected&&console.warn("Polyfill has already been injected..."),(e=>!!e.navigator.xr&&!(!e.XRMediaBinding||!e.XRWebGLBinding))(e)||(this._polyfillRequiredLayersFeature(e),this._polyfillXRSession(e),e.XRWebGLBinding=Z,e.XRMediaBinding=f,this.injected=!0,console.log("Injected Layers Polyfill"))}_polyfillXRSession(e){e.XRSession.prototype._updateRenderState=e.XRSession.prototype.updateRenderState,e.XRSession.prototype._requestAnimationFrame=e.XRSession.prototype.requestAnimationFrame;let t=Object.getOwnPropertyDescriptor(e.XRSession.prototype,"renderState");Object.defineProperty(e.XRSession.prototype,"_renderState",t);let r=Object.getOwnPropertyDescriptor(Q.prototype,"renderState");Object.defineProperty(e.XRSession.prototype,"renderState",r);let i=Object.getOwnPropertyNames(Q.prototype);for(let t of i){let r=Object.getOwnPropertyDescriptor(Q.prototype,t);Object.defineProperty(e.XRSession.prototype,t,r)}}_polyfillRequiredLayersFeature(e){const t=e.navigator.xr.requestSession;Object.defineProperty(e.navigator.xr,"requestSessionInternal",{writable:!0}),e.navigator.xr.requestSessionInternal=t;Object.defineProperty(e.navigator.xr,"requestSession",{writable:!0}),e.navigator.xr.requestSession=(t,r)=>{const i=(r,i)=>e.navigator.xr.requestSessionInternal(r,i).then((e=>{Object.assign(e,new Q);let r=e;return r.initializeSession(t),Promise.resolve(r)}));if("immersive-vr"!==t)return i(t,r);if(!r)return i(t,r);if(r.requiredFeatures&&r.requiredFeatures.indexOf("layers")>-1){const e=Object.assign({},r),s=[...r.requiredFeatures],o=s.indexOf("layers");return s.splice(o,1),e.requiredFeatures=s,i(t,e)}return i(t,r)}}}}));
